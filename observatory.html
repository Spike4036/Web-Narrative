<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>VIGIL — Realistic Orbital Investigator (p5.js)</title>
  <style>
    html,body{margin:0;height:100%;background:#05070E;color:#E6EEF7;font-family:ui-monospace,Consolas,Menlo,monospace}
    canvas{display:block}
    .hint{position:fixed;left:14px;top:12px;font-size:12px;opacity:.9;user-select:none;z-index:20}
    .footer{position:fixed;left:12px;right:12px;bottom:12px;padding:8px 14px;background:rgba(20,28,44,.75);backdrop-filter:blur(4px);font-size:12px;display:flex;align-items:center;gap:12px;border-radius:10px;z-index:20}
    .footer .sep{flex:1}
    .badge{padding:2px 8px;border-radius:999px;background:#1B2437;color:#E6EEF7;border:1px solid rgba(230,238,247,.2)}
    .panel{position:fixed;right:16px;top:16px;max-width:min(420px, 90vw);background:rgba(12,18,32,.94);border:1px solid rgba(230,238,247,.18);border-radius:10px;padding:12px;display:none;z-index:21}
    .panel h3{margin:0 0 6px 0;font-size:14px}
    .panel .row{font-size:12px;line-height:1.4;margin:4px 0}
    .panel .tag{display:inline-block;padding:1px 6px;border-radius:999px;background:#1B2437;border:1px solid rgba(230,238,247,.2);margin-right:6px}
    .panel .close{position:absolute;right:10px;top:8px;cursor:pointer;opacity:.8}
    /* Thin bezel that doesn't cover content */
    .bezel{position:fixed;inset:0;pointer-events:none;z-index:12}
    .bezel:after{content:"";position:absolute;inset:6px;border-radius:14px;border:12px solid #0b0f1a;box-shadow:0 0 0 1px rgba(230,238,247,.08) inset,0 10px 30px rgba(0,0,0,.35)}
  </style>
  <script>
  /**
   * Title: VIGIL — Realistic Orbital Investigator
   * Author: [Your Name]
   * Date: [Submission Date]
   *
   * AI Usage Statement:
   * This project includes AI-assisted elements. I used ChatGPT to help generate story ideas,
   * draft microcopy, and structure parts of the p5.js code (modes, HUD, intel system).
   * All AI outputs were reviewed, edited, and integrated by me.
   * Link to AI transcript: [paste your share link here]
   */
  </script>
</head>
<body>
  <div class="bezel"></div>
  <div class="hint">VIGIL — Drag = rotate Earth · 1/2/3 = Optical/IR/Radio · Hold SPACE = stabilize · Click anomalies/spectrum = collect intel · C = compose hypothesis · R = reset</div>
  <div id="intelPanel" class="panel">
    <div class="close" onclick="hidePanel()">✕</div>
    <h3 id="ip_title">Intel</h3>
    <div class="row" id="ip_type"></div>
    <div class="row" id="ip_loc"></div>
    <div class="row" id="ip_desc"></div>
    <div class="row" id="ip_note"></div>
  </div>
  <div class="footer">
    <span id="mode" class="badge">MODE: OPTICAL</span>
    <span id="intel" class="badge">INTEL: 0/12</span>
    <span id="hud" class="badge">LINK: nominal</span>
    <span class="sep"></span>
    <span>ESC = clear panel</span>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js"></script>
  <script>
  // =======================
  // VIGIL — Orbital Investigator (realistic starfield + Earth + 3 sensor modes)
  // =======================

  // ---- Palette ----
  const P = { bg:'#05070E', ink:'#E6EEF7', steel:'#1B2437', blue:'#89C7FF', cyan:'#7DF7D4', amber:'#F5A623', red:'#D64550' };

  // ---- HUD helpers ----
  const setMode = (s)=> document.getElementById('mode').textContent = 'MODE: ' + s;
  const setIntel = (n,m)=> document.getElementById('intel').textContent = `INTEL: ${n}/${m}`;
  const setHUD   = (s)=> document.getElementById('hud').textContent   = s;

  // ---- Scene state ----
  let stars = [];
  let cities = [];      // pseudo night lights (lat,lon)
  let anomalies = [];   // {id,type,lat,lon,desc,when,channel?}
  let intelSet = new Set();
  const INTEL_MAX = 12;

  // Earth orientation (yaw,pitch), sun yaw
  let yaw = 0.6, pitch = 0.2, yawVel = 0, pitchVel = 0;
  let sunYaw = -0.3; // sun direction around Earth (radians), equatorial
  let radius;         // Earth radius on screen

  // Sensor mode
  // 1 Optical, 2 IR, 3 Radio
  let mode = 1;

  // Spectrum analyzer (radio mode)
  const BINS = 64;
  let spectrum = new Array(BINS).fill(0);
  let spikeBins = []; // bins that carry "signal" intel

  // Opening event: ground link loss
  let t0; let linkLostAt = 5000; let linkDown = false;

  // ---- p5 setup ----
  function setup(){
    pixelDensity(1);
    createCanvas(window.innerWidth, window.innerHeight);
    radius = min(width,height)*0.33;
    t0 = millis();

    genStars(900);
    genCities(700);
    genAnomalies();
    genRadioSpikes();

    setMode('OPTICAL');
    setIntel(0, INTEL_MAX);
    setHUD('LINK: nominal');
  }

  function windowResized(){
    resizeCanvas(window.innerWidth, window.innerHeight);
    radius = min(width,height)*0.33;
  }

  // ---- Generators ----
  function genStars(n){
    randomSeed(7);
    stars=[];
    for(let i=0;i<n;i++){
      stars.push({
        x: random(-width,width),
        y: random(-height,height),
        s: random(0.6,1.8),
        b: random(80,200),
        tw: random(0.003,0.01)*random([1,-1])
      });
    }
  }

  // Generate city-light seeds in several longitude clusters (fake continents)
  function genCities(n){
    noiseSeed(11);
    cities=[];
    const clusters = [
      {lon:-100, lat:20}, // Americas
      {lon:0, lat:45},    // Europe
      {lon:100, lat:30},  // E/SE Asia
      {lon:80, lat:20},   // S Asia
      {lon:30, lat:0},    // Africa
    ];
    for(let i=0;i<n;i++){
      const c = random(clusters);
      const lon = c.lon + randomGaussian(0, 20);
      const lat = c.lat + randomGaussian(0, 12);
      cities.push({lat: constrain(lat,-70,70), lon: wrapLon(lon)});
    }
  }

  function genAnomalies(){
    anomalies = [
      mkAnom('RF carrier','Possible narrowband transmission',  34, 118, 'Band at 1420 MHz drifting +0.2 Hz/s', 'radio', 1420),
      mkAnom('Silent city','No night lights in megaregion',    40,  -74, 'Urban light grid absent across ~400 km', 'optical', null),
      mkAnom('Thermal plume','Upper-atmos heat anomaly',       23,   45, 'IR bloom at tropopause, expanding radius', 'ir', null),
      mkAnom('Debris cloud','Low inclination fragment field',  -5,  -10, 'Specular flashes suggest fresh breakup', 'optical', null),
      mkAnom('RF burst','Broadband impulsive event',           35,  139, 'Short, aperiodic; SNR spikes at 406 MHz', 'radio', 406),
      mkAnom('Hot spot','Persistent ground hot zone',          31,   35, 'Surface IR > 340K for 30 min', 'ir', null),
      mkAnom('Carrier dropout','Beacon loss corridor',         51,    0, 'GNSS/ADS-B silence across corridor', 'radio', 1575),
      mkAnom('Dark coastline','Terminator lights vanish',      55,    2, 'Coastal band dark under clear skies', 'optical', null),
      mkAnom('RF repeat','Repeating narrowband pattern',      -33,  151, 'Period ~73 s, weak Doppler', 'radio', 121.5),
      mkAnom('Thermal ring','Concentric IR halo',              48,  105, 'Possible wildfire/superstructure?', 'ir', null),
      mkAnom('Specular track','Sun glint moving track',         0, -150, 'High albedo object at ~400 km', 'optical', null),
      mkAnom('Wideband hiss','Background rises globally',       0,    0, 'Noise floor +6 dB, peak near 2.4 GHz', 'radio', 2400),
    ];
  }
  function mkAnom(type, title, lat, lon, desc, bestMode, channel){
    return {
      id: type+'@'+lat.toFixed(1)+','+lon.toFixed(1),
      type, title, lat, lon, desc, bestMode, channel
    };
  }

  function genRadioSpikes(){
    spikeBins=[];
    // Mark a few bins to contain signals matching anomalies with channel (MHz)
    const chans = anomalies.filter(a=>a.channel).map(a=>a.channel);
    for(const f of chans){
      const bin = floor(map(f, 100, 3000, 0, BINS-1, true));
      spikeBins.push({bin, fMHz:f});
    }
  }

  // ---- Core draw loop ----
  function draw(){
    background(P.bg);

    drawStars();

    const cx = width/2, cy = height/2;

    // Opening "link lost" event after 5s
    if(!linkDown && millis()-t0 > linkLostAt){
      linkDown = true;
      setHUD('LINK: lost — ground silent');
    }

    // Earth sphere
    drawEarth(cx, cy, radius);

    // Overlay anomalies for current mode
    drawAnomalies(cx, cy, radius);

    // Spectrum (radio)
    if(mode===3) drawSpectrum();

    // Inertia + stabilization
    yaw += yawVel; pitch += pitchVel;
    if(keyIsDown(32)){ yawVel *= 0.9; pitchVel *= 0.9; } // SPACE stabilize
    else { yawVel *= 0.98; pitchVel *= 0.98; }

    // Update spectrum values
    if(frameCount%1===0){
      for(let i=0;i<BINS;i++){
        const base = 0.3 + 0.7*noise(i*0.07, frameCount*0.02);
        spectrum[i] = lerp(spectrum[i], base, 0.5);
      }
      // Add spikes for marked bins
      for(const s of spikeBins){
        const idx = s.bin;
        spectrum[idx] = max(spectrum[idx], 0.85 + 0.15*sin(frameCount*0.25));
      }
    }

    // HUD
    setIntel(intelSet.size, INTEL_MAX);
  }

  // ---- Stars ----
  function drawStars(){
    push(); translate(width/2, height/2);
    noStroke();
    for(const st of stars){
      const tw = 120 + 60*Math.sin(frameCount*st.tw + st.x*0.002);
      fill(230,238,247, tw/8);
      circle(st.x, st.y, st.s);
    }
    pop();
  }

  // ---- Earth rendering ----
  function drawEarth(cx, cy, r){
    // Clip to circle and draw day/night gradient
    const ctx = drawingContext;
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.clip();

    // Linear gradient across terminator (aligned with sunYaw)
    const dx = Math.cos(sunYaw)*r*2;
    const dy = Math.sin(sunYaw)*r*2;
    const lg = ctx.createLinearGradient(cx-dx, cy-dy, cx+dx, cy+dy);
    // day → twilight → night
    lg.addColorStop(0.0, '#275b9b');
    lg.addColorStop(0.45, '#1f3f6d');
    lg.addColorStop(0.5, 'rgba(10,12,20,0.85)');
    lg.addColorStop(1.0, 'rgba(5,7,14,0.95)');
    ctx.fillStyle = lg;
    ctx.fillRect(cx-r, cy-r, r*2, r*2);

    // Subtle clouds (noise bands)
    noFill();
    stroke(230,238,247, 12);
    for(let i=0;i<20;i++){
      const a = i*0.15 + frameCount*0.002;
      const rr = r*random(0.3,0.95);
      arc(cx, cy, rr*2, rr*2, a, a+0.9);
    }

    // Night city lights (only on nightside)
    noStroke();
    for(const c of cities){
      const p = projectLatLon(c.lat, c.lon, yaw, pitch);
      if(!p || p.z>0) continue; // backface or day
      // Dot with sun dir to test night
      const n = p; // unit vector
      const sun = {x:Math.cos(sunYaw), y:0, z:Math.sin(sunYaw)};
      const dot = n.x*sun.x + n.y*sun.y + n.z*sun.z;
      if(dot > -0.15) continue; // only deep night
      const px = cx + n.x * r;
      const py = cy - n.y * r;
      const tw = 150 + 100*Math.sin(frameCount*0.05 + px*0.01);
      fill(245,166,35, tw/255*220);
      circle(px, py, random(0.6,1.6));
    }

    ctx.restore();

    // Atmosphere glow
    noFill();
    for(let i=0;i<18;i++){
      stroke(137,247,212, map(i,0,17,90,0));
      circle(cx, cy, r*2 + i*2);
    }

    // IR false-color overlay
    if(mode===2){
      const ctx2 = drawingContext;
      ctx2.save();
      ctx2.beginPath(); ctx2.arc(cx,cy,r,0,Math.PI*2); ctx2.clip();
      const lg2 = ctx2.createLinearGradient(cx-r, cy-r, cx+r, cy+r);
      lg2.addColorStop(0,'rgba(255,120,20,0.08)');
      lg2.addColorStop(1,'rgba(255,180,60,0.12)');
      ctx2.fillStyle = lg2; ctx2.fillRect(cx-r,cy-r,2*r,2*r);
      // Thermal speckles (procedural heat)
      noStroke();
      for(let i=0;i<650;i++){
        const ang = random(TWO_PI), rr = r*sqrt(random());
        const px = cx + rr*Math.cos(ang);
        const py = cy + rr*Math.sin(ang);
        if(dist(px,py,cx,cy)>r) continue;
        fill(245,166,35, random(20,60));
        circle(px, py, random(0.8,1.6));
      }
      ctx2.restore();
    }

    // Radio hotspots hint
    if(mode===3){
      for(const a of anomalies){
        if(a.bestMode!=='radio') continue;
        const p = projectLatLon(a.lat, a.lon, yaw, pitch);
        if(!p || p.z>0) continue;
        const px = cx + p.x*r, py = cy - p.y*r;
        noFill(); stroke(137,247,212, 160); strokeWeight(1.5);
        const pulse = 6 + 3*sin(frameCount*0.2 + px*0.01);
        circle(px, py, pulse);
      }
    }
  }

  // ---- Anomalies overlay & picking ----
  function drawAnomalies(cx, cy, r){
    textAlign(CENTER, TOP); textSize(11); noStroke();

    for(const a of anomalies){
      // Only show if relevant to mode (or show faintly)
      const p = projectLatLon(a.lat, a.lon, yaw, pitch);
      if(!p || p.z>0) continue; // back side
      const px = cx + p.x*r, py = cy - p.y*r;

      const isBest = (a.bestMode === (mode===1?'optical':mode===2?'ir':'radio'));
      const alpha = isBest ? 220 : 70;

      if(mode===1 && (a.bestMode==='optical' || isBest)){
        fill(233,240,255, alpha);
        circle(px, py, 5);
      } else if(mode===2 && (a.bestMode==='ir' || isBest)){
        fill(245,166,35, alpha);
        circle(px, py, 6);
      } else if(mode===3 && (a.bestMode==='radio' || isBest)){
        fill(137,247,212, alpha);
        circle(px, py, 6);
      }

      // Hover tooltip
      if(dist(mouseX, mouseY, px, py) < 10){
        drawTip(px+10, py-10, `${a.title}`);
      }
    }
  }

  // ---- Spectrum (radio mode) ----
  function drawSpectrum(){
    const pad = 16, h = 96, y0 = height - h - 62; // above footer
    const w = width - pad*2;
    const x0 = pad;

    // Frame
    noFill(); stroke(200,220,240,120); rect(x0, y0, w, h, 6);

    // Bars
    noStroke();
    for(let i=0;i<BINS;i++){
      const x = x0 + i*(w/BINS) + 2;
      const bw = (w/BINS) - 4;
      const v = spectrum[i];
      const bh = v*h*0.85;
      fill(137,199,255, 180);
      rect(x, y0 + h - bh, bw, bh, 2);
    }

    // Mark spike bins
    for(const s of spikeBins){
      const x = x0 + s.bin*(w/BINS);
      stroke(125,247,212, 180);
      line(x, y0, x, y0+h);
    }

    // Hover/click
    const hoverBin = floor(map(constrain(mouseX,x0,x0+w), x0, x0+w, 0, BINS));
    const hbX = x0 + hoverBin*(w/BINS);
    stroke(255,255,255,60); line(hbX, y0, hbX, y0+h);

    // Tooltip freq
    const fMHz = map(hoverBin, 0, BINS-1, 100, 3000).toFixed(0);
    drawTip(hbX+8, y0-18, `${fMHz} MHz`);
  }

  // ---- Interaction ----
  function mouseDragged(){
    // rotate Earth
    yawVel += (mouseX - pmouseX)*0.002;
    pitchVel += (pmouseY - mouseY)*0.002;
    pitch = constrain(pitch, -1.2, 1.2);
  }

  function mouseClicked(){
    // Click spectrum in radio mode
    if(mode===3){
      const pad = 16, h = 96, y0 = height - h - 62, x0 = pad, w = width - pad*2;
      if(mouseY>=y0 && mouseY<=y0+h && mouseX>=x0 && mouseX<=x0+w){
        const bin = floor(map(mouseX, x0, x0+w, 0, BINS-1, true));
        const spike = spikeBins.find(s=>s.bin===bin);
        if(spike){
          const a = anomalies.find(an=>an.channel && abs(map(an.channel,100,3000,0,BINS-1,true)-bin)<1);
          if(a) collectIntel(a, 'Radio capture at '+spike.fMHz+' MHz');
          return;
        }
      }
    }
    // Click anomalies on Earth
    const cx = width/2, cy = height/2;
    for(const a of anomalies){
      const p = projectLatLon(a.lat, a.lon, yaw, pitch);
      if(!p || p.z>0) continue;
      const px = cx + p.x*radius, py = cy - p.y*radius;
      if(dist(mouseX,mouseY,px,py) < 10){
        collectIntel(a, 'Geolocated on Earth-facing side');
        return;
      }
    }
    hidePanel();
  }

  function keyPressed(){
    if(key==='1'){ mode=1; setMode('OPTICAL'); }
    if(key==='2'){ mode=2; setMode('IR'); }
    if(key==='3'){ mode=3; setMode('RADIO'); }
    if(key==='c' || key==='C'){ composeHypothesis(); }
    if(key==='r' || key==='R'){ intelSet.clear(); hidePanel(); setIntel(0,INTEL_MAX); setHUD(linkDown?'LINK: lost — ground silent':'LINK: nominal'); }
    if(keyCode===27){ hidePanel(); } // ESC
  }

  // ---- Intel collection & panel ----
  function collectIntel(a, note){
    intelSet.add(a.id);
    showPanel(a, note);
    if(intelSet.size>=INTEL_MAX){
      setHUD('THRESHOLD: enough intel to hypothesize (press C)');
    } else {
      setHUD(`Collected: ${intelSet.size}/${INTEL_MAX}`);
    }
  }

  function showPanel(a, note){
    const el = document.getElementById('intelPanel');
    document.getElementById('ip_title').textContent = a.title;
    document.getElementById('ip_type').innerHTML = `<span class="tag">Type</span> ${a.type} · Best via ${a.bestMode.toUpperCase()}` + (a.channel?` · ${a.channel} MHz`:'');
    document.getElementById('ip_loc').innerHTML = `<span class="tag">Location</span> ${fmtLat(a.lat)}, ${fmtLon(a.lon)}`;
    document.getElementById('ip_desc').innerHTML = `<span class="tag">Observation</span> ${a.desc}`;
    document.getElementById('ip_note').innerHTML = `<span class="tag">Note</span> ${note}`;
    el.style.display = 'block';
  }
  function hidePanel(){ document.getElementById('intelPanel').style.display='none'; }
  window.hidePanel = hidePanel;

  // ---- Hypothesis composition ----
  function composeHypothesis(){
    const counts = {radio:0,optical:0,ir:0};
    const kinds = {carrier:0, silent:0, debris:0, thermal:0};
    for(const a of anomalies){
      if(intelSet.has(a.id)){
        counts[a.bestMode]++;
        if(a.type.includes('carrier') || a.type.includes('RF')) kinds.carrier++;
        if(a.type.includes('Silent')||a.type.includes('Dark')) kinds.silent++;
        if(a.type.includes('Debris')||a.type.includes('Specular')) kinds.debris++;
        if(a.type.includes('Thermal')||a.type.includes('Hot')) kinds.thermal++;
      }
    }
    const lines = [];
    lines.push('Working Hypothesis —');
    if(kinds.debris>=2) lines.push('• Multiple debris/flash tracks suggest widespread LEO fragmentation.');
    if(kinds.silent>=2) lines.push('• Urban light grids absent under clear skies ⇒ power grid collapse.');
    if(kinds.carrier>=2) lines.push('• Residual carriers persist on emergency/astro bands with Doppler drift.');
    if(kinds.thermal>=2) lines.push('• Thermal blooms indicate large-scale fires or energetic events.');
    const coverage = counts.radio+counts.optical+counts.ir;
    lines.push(`• Coverage: radio ${counts.radio}, optical ${counts.optical}, IR ${counts.ir} (${coverage} observations).`);
    if(lines.length<=2) lines.push('• Insufficient diversity; continue scanning for cross-sensor confirmation.');

    overlayText(lines.join('\n'));
  }

  // ---- Utility drawing ----
  function drawTip(x,y,msg){
    const pad = 6; textSize(11); textAlign(LEFT,TOP);
    const w = textWidth(msg) + pad*2; const h = 20;
    noStroke(); fill(27,36,55, 220); rect(x, y, w, h, 4);
    fill(P.ink); text(msg, x+pad, y+4);
  }

  // Temporary overlay text
  let overlay=null;
  function overlayText(txt){
    overlay = {txt, t: frameCount};
    // draw for 4 seconds
    const id = setInterval(()=>{
      if(!overlay || frameCount - overlay.t > 240){ overlay=null; clearInterval(id); }
    }, 100);
    // Also show now
    drawOverlayNow(txt);
  }
  function drawOverlayNow(txt){
    const ctx = drawingContext;
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,width,height);
    fill(P.ink); textSize(16); textAlign(CENTER,CENTER);
    text(txt, width/2, height/2);
    ctx.restore();
  }

  // p5 doesn't auto-call after overlay set; ensure drawn in next frame
  const _draw = draw;
  // (we keep overlay fade implicit by time check inside setInterval)

  // ---- Math helpers ----
  function projectLatLon(lat, lon, yaw, pitch){
    // Convert to 3D unit vector, apply yaw (around y) and pitch (around x), orthographic project
    const la = radians(lat), lo = radians(lon);
    let x = Math.cos(la)*Math.cos(lo);
    let y = Math.sin(la);
    let z = Math.cos(la)*Math.sin(lo);
    // yaw
    const cosy = Math.cos(yaw), siny = Math.sin(yaw);
    let x1 = cosy*x + siny*z;
    let z1 = -siny*x + cosy*z;
    // pitch
    const cpx = Math.cos(pitch), spx = Math.sin(pitch);
    let y2 = cpx*y - spx*z1;
    let z2 = spx*y + cpx*z1;
    // front side is z2 < 0 (toward viewer)
    if(z2 > 0) return {x:x1, y:y2, z:z2}; // we still return for culling decisions
    return {x:x1, y:y2, z:z2};
  }

  function fmtLat(v){ return `${abs(v).toFixed(1)}° ${v>=0?'N':'S'}`; }
  function fmtLon(v){ return `${abs(v).toFixed(1)}° ${v>=0?'E':'W'}`; }
  function wrapLon(v){ let x=v; while(x<-180) x+=360; while(x>180) x-=360; return x; }

  </script>
</body>
</html>